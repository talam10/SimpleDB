Runtime Results:
—--------------------

Query1: 0.26 seconds
Query2: more than twenty minutes ( we got impatient after that so killed it)
Query3: more than twenty minutes ( we got impatient after that so killed it)

What was this lab about?
—------------------------------

In this lab we implemented some of the key components of our SimpleDB.
These implementations in lab2 allow us to modify, do selections, joins and aggregates.
We built out the basic structure in lab1, and that structure was only able to handle queries.
Now, in lab2 we are also handling the buffer pool management.
We need to address the problem of referencing more pages than can fit in memory.

The main focus of this lab was to implement the operators for SimpleDB, including Filter, Join, Aggregate, IntegerAggregator, StringAggregator, Insert, and Delete.
These allow us to perform some more complex queries.
We can now query multiple tables, perform filtering, joining, and aggregating data files.
Our filtering operator is responsible for returning tuples that satisfy whatever the given Predicate is.
The Aggregators were also able to support both strings and integers. This allows us to aggregate numerous data types.

We worked in the BufferPool to handle things like insertion, deletion, and page eviction.
We worked inside HeapFile and HeapPage to add and remove tuples.
We also implemented the Insert and Delete operators, which modified the pages on disk and returned the number of affected tuples.
We designed an eviction policy for the buffer pool to manage the memory usage efficiently.
At this point we are using a FIFO eviction policy.
This approach may change in the future, as we can see from the queries we ran that we are encountering some timeout issues.
We may switch to random eviction in future iterations of SimpleDB.

Design Decisions:
—---------------------
IntegerAggregator:
I made a helper function named CalculateAvg CalculateAvg essentially calculates the average separately.
It only gathers the MergeTuple info for SUM and COUNT. Then calculates AVG inside the function.
My initial design decision was that I wanted to calculate everything inside the merge tuple and then have NO GROUPING inside the OpIterator where I will calculate the AVG once again.
However, it was not passing the system tests of aggregator so I had to switch to the helper function method.

Join:
We used a nested loop join implementation for our fetchJoin() method inside the Join file.
This is comparatively slow for the queries we are trying to execute but we will try our best to implement a hashJoin method (if we have time).

BufferPool:
Besides that, we also used a FIFO (first in First Out) eviction policy for our evictPage() method in the BufferPool file.
Although randomized eviction might have been a better option, we decided to stick with this policy for now.
In our implementation, the pages are evicted in the order they were inserted in the bufferpool by entryset() iterating over the pages they were added to our Map.Entry.
It then evicts the first dirtyPage it encounters.



Unit Test Example:
—---------------------
We can add a test for evicting dirty pages from the BufferPool when it exceeds the maximum number of pages.
The test should verify that the eviction of dirty pages is handled properly. It should write the changes to disk before removing the page from the buffer.
The test would insert maxPages + 1 tuples, which will cause the BufferPool to evict a dirty page.
It should then check if the evicted page was properly written to disk by counting the number of tuples in the HeapFile and comparing it to the number of inserted tuples.

API Changes?
—----------------
None.

Missing/Incomplete Elements:
—-------------------------------------
None.

